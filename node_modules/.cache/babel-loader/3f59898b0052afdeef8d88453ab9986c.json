{"ast":null,"code":"'use strict';\n\nvar merge = require('../functions/merge');\n\nvar defaultsPure = require('../functions/defaultsPure');\n\nvar orderBy = require('../functions/orderBy');\n\nvar compact = require('../functions/compact');\n\nvar find = require('../functions/find');\n\nvar findIndex = require('../functions/findIndex');\n\nvar formatSort = require('../functions/formatSort');\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\n/**\n * @param {string[]} attributes\n */\n\n\nfunction getIndices(attributes) {\n  var indices = {};\n  attributes.forEach(function (val, idx) {\n    indices[val] = idx;\n  });\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n/**\n * @typedef {Object} HierarchicalFacet\n * @property {string} name\n * @property {string[]} attributes\n */\n\n/**\n * @param {HierarchicalFacet[]} hierarchicalFacets\n * @param {string} hierarchicalAttributeName\n */\n\n\nfunction findMatchingHierarchicalFacetFromAttributeName(hierarchicalFacets, hierarchicalAttributeName) {\n  return find(hierarchicalFacets, function facetKeyMatchesAttribute(hierarchicalFacet) {\n    var facetNames = hierarchicalFacet.attributes || [];\n    return facetNames.indexOf(hierarchicalAttributeName) > -1;\n  });\n}\n/*eslint-disable */\n\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\n\n/*eslint-enable */\n\n\nfunction SearchResults(state, results) {\n  var mainSubResponse = results[0];\n  this._rawResults = results;\n  /**\n   * query used to generate the results\n   * @member {string}\n   */\n\n  this.query = mainSubResponse.query;\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @member {string}\n   */\n\n  this.parsedQuery = mainSubResponse.parsedQuery;\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   *  - `value` : the value of the facet highlighted (html)\n   *  - `matchLevel`: full, partial or none depending on how the query terms match\n   * @member {object[]}\n   */\n\n  this.hits = mainSubResponse.hits;\n  /**\n   * index where the results come from\n   * @member {string}\n   */\n\n  this.index = mainSubResponse.index;\n  /**\n   * number of hits per page requested\n   * @member {number}\n   */\n\n  this.hitsPerPage = mainSubResponse.hitsPerPage;\n  /**\n   * total number of hits of this query on the index\n   * @member {number}\n   */\n\n  this.nbHits = mainSubResponse.nbHits;\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @member {number}\n   */\n\n  this.nbPages = mainSubResponse.nbPages;\n  /**\n   * current page\n   * @member {number}\n   */\n\n  this.page = mainSubResponse.page;\n  /**\n   * sum of the processing time of all the queries\n   * @member {number}\n   */\n\n  this.processingTimeMS = results.reduce(function (sum, result) {\n    return result.processingTimeMS === undefined ? sum : sum + result.processingTimeMS;\n  }, 0);\n  /**\n   * The position if the position was guessed by IP.\n   * @member {string}\n   * @example \"48.8637,2.3615\",\n   */\n\n  this.aroundLatLng = mainSubResponse.aroundLatLng;\n  /**\n   * The radius computed by Algolia.\n   * @member {string}\n   * @example \"126792922\",\n   */\n\n  this.automaticRadius = mainSubResponse.automaticRadius;\n  /**\n   * String identifying the server used to serve this request.\n   *\n   * getRankingInfo needs to be set to `true` for this to be returned\n   *\n   * @member {string}\n   * @example \"c7-use-2.algolia.net\",\n   */\n\n  this.serverUsed = mainSubResponse.serverUsed;\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n\n  this.timeoutCounts = mainSubResponse.timeoutCounts;\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n\n  this.timeoutHits = mainSubResponse.timeoutHits;\n  /**\n   * True if the counts of the facets is exhaustive\n   * @member {boolean}\n   */\n\n  this.exhaustiveFacetsCount = mainSubResponse.exhaustiveFacetsCount;\n  /**\n   * True if the number of hits is exhaustive\n   * @member {boolean}\n   */\n\n  this.exhaustiveNbHits = mainSubResponse.exhaustiveNbHits;\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @member {object[]}\n   */\n\n  this.userData = mainSubResponse.userData;\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @member {string}\n   */\n\n  this.queryID = mainSubResponse.queryID;\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n\n  this.hierarchicalFacets = state.hierarchicalFacets.map(function initFutureTree() {\n    return [];\n  });\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n\n  this.facets = [];\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n  var self = this; // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets information from the first, general, response.\n\n  var mainFacets = mainSubResponse.facets || {};\n  Object.keys(mainFacets).forEach(function (facetKey) {\n    var facetValueObject = mainFacets[facetKey];\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(state.hierarchicalFacets, facetKey);\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function (f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  }); // Make sure we do not keep holes within the hierarchical facets\n\n  this.hierarchicalFacets = compact(this.hierarchicalFacets); // aggregate the refined disjunctive facets\n\n  disjunctiveFacets.forEach(function (disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet); // There should be only item in facets.\n\n    Object.keys(facets).forEach(function (dfacet) {\n      var facetResults = facets[dfacet];\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, function (f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], function (f) {\n          return f.attribute === dfacet;\n        }); // previous refinements and no results so not able to find it\n\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge({}, self.hierarchicalFacets[position][attributeIndex].data, facetResults);\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function (refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] && state.disjunctiveFacetsRefinements[dfacet].indexOf(refinementValue) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  }); // if we have some root level values for hierarchical facets, merge them\n\n  state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet); // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    Object.keys(facets).forEach(function (dfacet) {\n      var facetResults = facets[dfacet];\n      var position = findIndex(state.hierarchicalFacets, function (f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      var attributeIndex = findIndex(self.hierarchicalFacets[position], function (f) {\n        return f.attribute === dfacet;\n      }); // previous refinements and no results so not able to find it\n\n      if (attributeIndex === -1) {\n        return;\n      } // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n      // then the disjunctive values will be `beers` (count: 100),\n      // but we do not want to display\n      //   | beers (100)\n      //     > IPA (5)\n      // We want\n      //   | beers (5)\n      //     > IPA (5)\n\n\n      var defaultData = {};\n\n      if (currentRefinement.length > 0) {\n        var root = currentRefinement[0].split(separator)[0];\n        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n      }\n\n      self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(defaultData, facetResults, self.hierarchicalFacets[position][attributeIndex].data);\n    });\n    nextDisjunctiveResult++;\n  }); // add the excludes\n\n  Object.keys(state.facetsExcludes).forEach(function (facetName) {\n    var excludes = state.facetsExcludes[facetName];\n    var position = facetsIndices[facetName];\n    self.facets[position] = {\n      name: facetName,\n      data: mainSubResponse.facets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    excludes.forEach(function (facetValue) {\n      self.facets[position] = self.facets[position] || {\n        name: facetName\n      };\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n  /**\n   * @type {Array}\n   */\n\n  this.hierarchicalFacets = this.hierarchicalFacets.map(generateHierarchicalTree(state));\n  /**\n   * @type {Array}\n   */\n\n  this.facets = compact(this.facets);\n  /**\n   * @type {Array}\n   */\n\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n  this._state = state;\n}\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\n\n\nSearchResults.prototype.getFacetByName = function (name) {\n  function predicate(facet) {\n    return facet.name === name;\n  }\n\n  return find(this.facets, predicate) || find(this.disjunctiveFacets, predicate) || find(this.hierarchicalFacets, predicate);\n};\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\n\n\nfunction extractNormalizedFacetValues(results, attribute) {\n  function predicate(facet) {\n    return facet.name === attribute;\n  }\n\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n    return Object.keys(facet.data).map(function (name) {\n      return {\n        name: name,\n        count: facet.data[name],\n        isRefined: results._state.isFacetRefined(attribute, name),\n        isExcluded: results._state.isExcludeRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n    return Object.keys(disjunctiveFacet.data).map(function (name) {\n      return {\n        name: name,\n        count: disjunctiveFacet.data[name],\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    return find(results.hierarchicalFacets, predicate);\n  }\n}\n/**\n * Sort nodes of a hierarchical facet results\n * @private\n * @param {HierarchicalFacet} node node to upon which we want to apply the sort\n */\n\n\nfunction recSort(sortFn, node) {\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n\n  var children = node.data.map(function (childNode) {\n    return recSort(sortFn, childNode);\n  });\n  var sortedChildren = sortFn(children);\n  var newNode = merge({}, node, {\n    data: sortedChildren\n  });\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('result', function(event){\n *   //get values ordered only by name ascending using the string predicate\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   event.results.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\n\n\nSearchResults.prototype.getFacetValues = function (attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n\n  if (!facetValues) {\n    return undefined;\n  }\n\n  var options = defaultsPure({}, opts, {\n    sortBy: SearchResults.DEFAULT_SORT\n  });\n\n  if (Array.isArray(options.sortBy)) {\n    var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n\n    if (Array.isArray(facetValues)) {\n      return orderBy(facetValues, order[0], order[1]);\n    } // If facetValues is not an array, it's an object thus a hierarchical facet object\n\n\n    return recSort(function (hierarchicalFacetValues) {\n      return orderBy(hierarchicalFacetValues, order[0], order[1]);\n    }, facetValues);\n  } else if (typeof options.sortBy === 'function') {\n    if (Array.isArray(facetValues)) {\n      return facetValues.sort(options.sortBy);\n    } // If facetValues is not an array, it's an object thus a hierarchical facet object\n\n\n    return recSort(function (data) {\n      return vanillaSortFn(options.sortBy, data);\n    }, facetValues);\n  }\n\n  throw new Error('options.sortBy is optional but if defined it must be ' + 'either an array of string (predicates) or a sorting function');\n};\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\n\n\nSearchResults.prototype.getFacetStats = function (attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  return undefined;\n};\n/**\n * @typedef {Object} FacetListItem\n * @property {string} name\n */\n\n/**\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\n * @param {string} facetName\n */\n\n\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, function (facet) {\n    return facet.name === facetName;\n  });\n  return data && data.stats;\n}\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhaustiveness for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * Note that for a numeric refinement, results are grouped per operator, this\n * means that it will return responses for operators which are empty.\n *\n * @return {Array.<Refinement>} all the refinements\n */\n\n\nSearchResults.prototype.getRefinements = function () {\n  var state = this._state;\n  var results = this;\n  var res = [];\n  Object.keys(state.facetsRefinements).forEach(function (attributeName) {\n    state.facetsRefinements[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n  Object.keys(state.facetsExcludes).forEach(function (attributeName) {\n    state.facetsExcludes[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function (attributeName) {\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function (attributeName) {\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n  Object.keys(state.numericRefinements).forEach(function (attributeName) {\n    var operators = state.numericRefinements[attributeName];\n    Object.keys(operators).forEach(function (operator) {\n      operators[operator].forEach(function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n  state.tagRefinements.forEach(function (name) {\n    res.push({\n      type: 'tag',\n      attributeName: '_tags',\n      name: name\n    });\n  });\n  return res;\n};\n/**\n * @typedef {Object} Facet\n * @property {string} name\n * @property {Object} data\n * @property {boolean} exhaustive\n */\n\n/**\n * @param {*} state\n * @param {*} type\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\n\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, function (f) {\n    return f.name === attributeName;\n  });\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\n  var exhaustive = facet && facet.exhaustive || false;\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n/**\n * @param {*} state\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\n\n\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\n\n  var split = name.split(separator);\n  var rootFacet = find(resultsFacets, function (facet) {\n    return facet.name === attributeName;\n  });\n  var facet = split.reduce(function (intermediateFacet, part) {\n    var newFacet = intermediateFacet && find(intermediateFacet.data, function (f) {\n      return f.name === part;\n    });\n    return newFacet !== undefined ? newFacet : intermediateFacet;\n  }, rootFacet);\n  var count = facet && facet.count || 0;\n  var exhaustive = facet && facet.exhaustive || false;\n  var path = facet && facet.path || '';\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: path,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\nmodule.exports = SearchResults;","map":{"version":3,"sources":["C:/Users/Sonja/search/search/node_modules/algoliasearch-helper/src/SearchResults/index.js"],"names":["merge","require","defaultsPure","orderBy","compact","find","findIndex","formatSort","generateHierarchicalTree","getIndices","attributes","indices","forEach","val","idx","assignFacetStats","dest","facetStats","key","stats","findMatchingHierarchicalFacetFromAttributeName","hierarchicalFacets","hierarchicalAttributeName","facetKeyMatchesAttribute","hierarchicalFacet","facetNames","indexOf","SearchResults","state","results","mainSubResponse","_rawResults","query","parsedQuery","hits","index","hitsPerPage","nbHits","nbPages","page","processingTimeMS","reduce","sum","result","undefined","aroundLatLng","automaticRadius","serverUsed","timeoutCounts","timeoutHits","exhaustiveFacetsCount","exhaustiveNbHits","userData","queryID","disjunctiveFacets","map","initFutureTree","facets","getRefinedDisjunctiveFacets","facetsIndices","disjunctiveFacetsIndices","nextDisjunctiveResult","self","mainFacets","Object","keys","facetKey","facetValueObject","facetIndex","idxAttributeName","f","name","attribute","data","exhaustive","isFacetDisjunctive","isFacetConjunctive","position","facets_stats","disjunctiveFacet","getHierarchicalFacetByName","dfacet","facetResults","attributeIndex","dataFromMainRequest","disjunctiveFacetsRefinements","refinementValue","getRefinedHierarchicalFacets","refinedFacet","separator","_getHierarchicalFacetSeparator","currentRefinement","getHierarchicalRefinement","length","split","defaultData","root","facetsExcludes","facetName","excludes","facetValue","_state","prototype","getFacetByName","predicate","facet","extractNormalizedFacetValues","isConjunctiveFacet","count","isRefined","isFacetRefined","isExcluded","isExcludeRefined","isDisjunctiveFacet","isDisjunctiveFacetRefined","isHierarchicalFacet","recSort","sortFn","node","children","childNode","sortedChildren","newNode","DEFAULT_SORT","vanillaSortFn","order","sort","getFacetValues","opts","facetValues","options","sortBy","Array","isArray","hierarchicalFacetValues","Error","getFacetStats","getFacetStatsIfAvailable","facetList","getRefinements","res","facetsRefinements","attributeName","push","getRefinement","hierarchicalFacetsRefinements","numericRefinements","operators","operator","value","type","numericValue","tagRefinements","resultsFacets","facetDeclaration","rootFacet","intermediateFacet","part","newFacet","path","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar merge = require('../functions/merge');\nvar defaultsPure = require('../functions/defaultsPure');\nvar orderBy = require('../functions/orderBy');\nvar compact = require('../functions/compact');\nvar find = require('../functions/find');\nvar findIndex = require('../functions/findIndex');\nvar formatSort = require('../functions/formatSort');\n\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n\n/**\n * @typedef SearchResults.Facet\n * @type {object}\n * @property {string} name name of the attribute in the record\n * @property {object} data the faceting data: value, number of entries\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\n */\n\n/**\n * @typedef SearchResults.HierarchicalFacet\n * @type {object}\n * @property {string} name name of the current value given the hierarchical level, trimmed.\n * If root node, you get the facet name\n * @property {number} count number of objects matching this hierarchical value\n * @property {string} path the current hierarchical value full path\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\n * @property {HierarchicalFacet[]} data sub values for the current level\n */\n\n/**\n * @typedef SearchResults.FacetValue\n * @type {object}\n * @property {string} name the facet value itself\n * @property {number} count times this facet appears in the results\n * @property {boolean} isRefined is the facet currently selected\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\n */\n\n/**\n * @typedef Refinement\n * @type {object}\n * @property {string} type the type of filter used:\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\n * @property {string} attributeName name of the attribute used for filtering\n * @property {string} name the value of the filter\n * @property {number} numericValue the value as a number. Only for numeric filters.\n * @property {string} operator the operator used. Only for numeric filters.\n * @property {number} count the number of computed hits for this filter. Only on facets.\n * @property {boolean} exhaustive if the count is exhaustive\n */\n\n/**\n * @param {string[]} attributes\n */\nfunction getIndices(attributes) {\n  var indices = {};\n\n  attributes.forEach(function(val, idx) {\n    indices[val] = idx;\n  });\n\n  return indices;\n}\n\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n\n/**\n * @typedef {Object} HierarchicalFacet\n * @property {string} name\n * @property {string[]} attributes\n */\n\n/**\n * @param {HierarchicalFacet[]} hierarchicalFacets\n * @param {string} hierarchicalAttributeName\n */\nfunction findMatchingHierarchicalFacetFromAttributeName(\n  hierarchicalFacets,\n  hierarchicalAttributeName\n) {\n  return find(hierarchicalFacets, function facetKeyMatchesAttribute(\n    hierarchicalFacet\n  ) {\n    var facetNames = hierarchicalFacet.attributes || [];\n    return facetNames.indexOf(hierarchicalAttributeName) > -1;\n  });\n}\n\n/*eslint-disable */\n/**\n * Constructor for SearchResults\n * @class\n * @classdesc SearchResults contains the results of a query to Algolia using the\n * {@link AlgoliaSearchHelper}.\n * @param {SearchParameters} state state that led to the response\n * @param {array.<object>} results the results from algolia client\n * @example <caption>SearchResults of the first query in\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\n{\n   \"hitsPerPage\": 10,\n   \"processingTimeMS\": 2,\n   \"facets\": [\n      {\n         \"name\": \"type\",\n         \"data\": {\n            \"HardGood\": 6627,\n            \"BlackTie\": 550,\n            \"Music\": 665,\n            \"Software\": 131,\n            \"Game\": 456,\n            \"Movie\": 1571\n         },\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"Free shipping\": 5507\n         },\n         \"name\": \"shipping\"\n      }\n  ],\n   \"hits\": [\n      {\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\n         \"_highlightResult\": {\n            \"shortDescription\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n               \"matchedWords\": []\n            },\n            \"category\": {\n               \"matchLevel\": \"none\",\n               \"value\": \"Computer Security Software\",\n               \"matchedWords\": []\n            },\n            \"manufacturer\": {\n               \"matchedWords\": [],\n               \"value\": \"Webroot\",\n               \"matchLevel\": \"none\"\n            },\n            \"name\": {\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n               \"matchedWords\": [],\n               \"matchLevel\": \"none\"\n            }\n         },\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\n         \"shipping\": \"Free shipping\",\n         \"bestSellingRank\": 4,\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\n         \"category\": \"Computer Security Software\",\n         \"salePrice_range\": \"1 - 50\",\n         \"objectID\": \"1688832\",\n         \"type\": \"Software\",\n         \"customerReviewCount\": 5980,\n         \"salePrice\": 49.99,\n         \"manufacturer\": \"Webroot\"\n      },\n      ....\n  ],\n   \"nbHits\": 10000,\n   \"disjunctiveFacets\": [\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"5\": 183,\n            \"12\": 112,\n            \"7\": 149,\n            ...\n         },\n         \"name\": \"customerReviewCount\",\n         \"stats\": {\n            \"max\": 7461,\n            \"avg\": 157.939,\n            \"min\": 1\n         }\n      },\n      {\n         \"data\": {\n            \"Printer Ink\": 142,\n            \"Wireless Speakers\": 60,\n            \"Point & Shoot Cameras\": 48,\n            ...\n         },\n         \"name\": \"category\",\n         \"exhaustive\": false\n      },\n      {\n         \"exhaustive\": false,\n         \"data\": {\n            \"> 5000\": 2,\n            \"1 - 50\": 6524,\n            \"501 - 2000\": 566,\n            \"201 - 500\": 1501,\n            \"101 - 200\": 1360,\n            \"2001 - 5000\": 47\n         },\n         \"name\": \"salePrice_range\"\n      },\n      {\n         \"data\": {\n            \"Dynex™\": 202,\n            \"Insignia™\": 230,\n            \"PNY\": 72,\n            ...\n         },\n         \"name\": \"manufacturer\",\n         \"exhaustive\": false\n      }\n  ],\n   \"query\": \"\",\n   \"nbPages\": 100,\n   \"page\": 0,\n   \"index\": \"bestbuy\"\n}\n **/\n/*eslint-enable */\nfunction SearchResults(state, results) {\n  var mainSubResponse = results[0];\n\n  this._rawResults = results;\n\n  /**\n   * query used to generate the results\n   * @member {string}\n   */\n  this.query = mainSubResponse.query;\n  /**\n   * The query as parsed by the engine given all the rules.\n   * @member {string}\n   */\n  this.parsedQuery = mainSubResponse.parsedQuery;\n  /**\n   * all the records that match the search parameters. Each record is\n   * augmented with a new attribute `_highlightResult`\n   * which is an object keyed by attribute and with the following properties:\n   *  - `value` : the value of the facet highlighted (html)\n   *  - `matchLevel`: full, partial or none depending on how the query terms match\n   * @member {object[]}\n   */\n  this.hits = mainSubResponse.hits;\n  /**\n   * index where the results come from\n   * @member {string}\n   */\n  this.index = mainSubResponse.index;\n  /**\n   * number of hits per page requested\n   * @member {number}\n   */\n  this.hitsPerPage = mainSubResponse.hitsPerPage;\n  /**\n   * total number of hits of this query on the index\n   * @member {number}\n   */\n  this.nbHits = mainSubResponse.nbHits;\n  /**\n   * total number of pages with respect to the number of hits per page and the total number of hits\n   * @member {number}\n   */\n  this.nbPages = mainSubResponse.nbPages;\n  /**\n   * current page\n   * @member {number}\n   */\n  this.page = mainSubResponse.page;\n  /**\n   * sum of the processing time of all the queries\n   * @member {number}\n   */\n  this.processingTimeMS = results.reduce(function(sum, result) {\n    return result.processingTimeMS === undefined\n      ? sum\n      : sum + result.processingTimeMS;\n  }, 0);\n  /**\n   * The position if the position was guessed by IP.\n   * @member {string}\n   * @example \"48.8637,2.3615\",\n   */\n  this.aroundLatLng = mainSubResponse.aroundLatLng;\n  /**\n   * The radius computed by Algolia.\n   * @member {string}\n   * @example \"126792922\",\n   */\n  this.automaticRadius = mainSubResponse.automaticRadius;\n  /**\n   * String identifying the server used to serve this request.\n   *\n   * getRankingInfo needs to be set to `true` for this to be returned\n   *\n   * @member {string}\n   * @example \"c7-use-2.algolia.net\",\n   */\n  this.serverUsed = mainSubResponse.serverUsed;\n  /**\n   * Boolean that indicates if the computation of the counts did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n  this.timeoutCounts = mainSubResponse.timeoutCounts;\n  /**\n   * Boolean that indicates if the computation of the hits did time out.\n   * @deprecated\n   * @member {boolean}\n   */\n  this.timeoutHits = mainSubResponse.timeoutHits;\n\n  /**\n   * True if the counts of the facets is exhaustive\n   * @member {boolean}\n   */\n  this.exhaustiveFacetsCount = mainSubResponse.exhaustiveFacetsCount;\n\n  /**\n   * True if the number of hits is exhaustive\n   * @member {boolean}\n   */\n  this.exhaustiveNbHits = mainSubResponse.exhaustiveNbHits;\n\n\n  /**\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\n   * @member {object[]}\n   */\n  this.userData = mainSubResponse.userData;\n\n  /**\n   * queryID is the unique identifier of the query used to generate the current search results.\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\n   * @member {string}\n   */\n  this.queryID = mainSubResponse.queryID;\n\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.disjunctiveFacets = [];\n  /**\n   * disjunctive facets results\n   * @member {SearchResults.HierarchicalFacet[]}\n   */\n  this.hierarchicalFacets = state.hierarchicalFacets.map(function initFutureTree() {\n    return [];\n  });\n  /**\n   * other facets results\n   * @member {SearchResults.Facet[]}\n   */\n  this.facets = [];\n\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n\n  var self = this;\n  // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets information from the first, general, response.\n\n  var mainFacets = mainSubResponse.facets || {};\n\n  Object.keys(mainFacets).forEach(function(facetKey) {\n    var facetValueObject = mainFacets[facetKey];\n\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(\n      state.hierarchicalFacets,\n      facetKey\n    );\n\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function(f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\n      var position;\n\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  });\n\n  // Make sure we do not keep holes within the hierarchical facets\n  this.hierarchicalFacets = compact(this.hierarchicalFacets);\n\n  // aggregate the refined disjunctive facets\n  disjunctiveFacets.forEach(function(disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);\n\n    // There should be only item in facets.\n    Object.keys(facets).forEach(function(dfacet) {\n      var facetResults = facets[dfacet];\n\n      var position;\n\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, function(f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], function(f) {\n          return f.attribute === dfacet;\n        });\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        self.hierarchicalFacets[position][attributeIndex].data = merge(\n          {},\n          self.hierarchicalFacets[position][attributeIndex].data,\n          facetResults\n        );\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function(refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] &&\n              state.disjunctiveFacetsRefinements[dfacet].indexOf(refinementValue) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  });\n\n  // if we have some root level values for hierarchical facets, merge them\n  state.getRefinedHierarchicalFacets().forEach(function(refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n    // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets\n      ? result.facets\n      : {};\n    Object.keys(facets).forEach(function(dfacet) {\n      var facetResults = facets[dfacet];\n      var position = findIndex(state.hierarchicalFacets, function(f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      var attributeIndex = findIndex(self.hierarchicalFacets[position], function(f) {\n        return f.attribute === dfacet;\n      });\n\n      // previous refinements and no results so not able to find it\n      if (attributeIndex === -1) {\n        return;\n      }\n\n      // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n      // then the disjunctive values will be `beers` (count: 100),\n      // but we do not want to display\n      //   | beers (100)\n      //     > IPA (5)\n      // We want\n      //   | beers (5)\n      //     > IPA (5)\n      var defaultData = {};\n\n      if (currentRefinement.length > 0) {\n        var root = currentRefinement[0].split(separator)[0];\n        defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n      }\n\n      self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(\n        defaultData,\n        facetResults,\n        self.hierarchicalFacets[position][attributeIndex].data\n      );\n    });\n\n    nextDisjunctiveResult++;\n  });\n\n  // add the excludes\n  Object.keys(state.facetsExcludes).forEach(function(facetName) {\n    var excludes = state.facetsExcludes[facetName];\n    var position = facetsIndices[facetName];\n\n    self.facets[position] = {\n      name: facetName,\n      data: mainSubResponse.facets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    excludes.forEach(function(facetValue) {\n      self.facets[position] = self.facets[position] || {name: facetName};\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n\n  /**\n   * @type {Array}\n   */\n  this.hierarchicalFacets = this.hierarchicalFacets.map(generateHierarchicalTree(state));\n\n  /**\n   * @type {Array}\n   */\n  this.facets = compact(this.facets);\n  /**\n   * @type {Array}\n   */\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n\n  this._state = state;\n}\n\n/**\n * Get a facet object with its name\n * @deprecated\n * @param {string} name name of the faceted attribute\n * @return {SearchResults.Facet} the facet object\n */\nSearchResults.prototype.getFacetByName = function(name) {\n  function predicate(facet) {\n    return facet.name === name;\n  }\n\n  return find(this.facets, predicate) ||\n    find(this.disjunctiveFacets, predicate) ||\n    find(this.hierarchicalFacets, predicate);\n};\n\n/**\n * Get the facet values of a specified attribute from a SearchResults object.\n * @private\n * @param {SearchResults} results the search results to search in\n * @param {string} attribute name of the faceted attribute to search for\n * @return {array|object} facet values. For the hierarchical facets it is an object.\n */\nfunction extractNormalizedFacetValues(results, attribute) {\n  function predicate(facet) {\n    return facet.name === attribute;\n  }\n\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n\n    return Object.keys(facet.data).map(function(name) {\n      return {\n        name: name,\n        count: facet.data[name],\n        isRefined: results._state.isFacetRefined(attribute, name),\n        isExcluded: results._state.isExcludeRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n\n    return Object.keys(disjunctiveFacet.data).map(function(name) {\n      return {\n        name: name,\n        count: disjunctiveFacet.data[name],\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    return find(results.hierarchicalFacets, predicate);\n  }\n}\n\n/**\n * Sort nodes of a hierarchical facet results\n * @private\n * @param {HierarchicalFacet} node node to upon which we want to apply the sort\n */\nfunction recSort(sortFn, node) {\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n\n  var children = node.data.map(function(childNode) {\n    return recSort(sortFn, childNode);\n  });\n  var sortedChildren = sortFn(children);\n  var newNode = merge({}, node, {data: sortedChildren});\n  return newNode;\n}\n\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\n\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n\n/**\n * Get a the list of values for a given facet attribute. Those values are sorted\n * refinement first, descending count (bigger value on top), and name ascending\n * (alphabetical order). The sort formula can overridden using either string based\n * predicates or a function.\n *\n * This method will return all the values returned by the Algolia engine plus all\n * the values already refined. This means that it can happen that the\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\n * might not be respected if you have facet values that are already refined.\n * @param {string} attribute attribute name\n * @param {object} opts configuration options.\n * @param {Array.<string> | function} opts.sortBy\n * When using strings, it consists of\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\n * order (`asc` or `desc`). For example to order the value by count, the\n * argument would be `['count:asc']`.\n *\n * If only the attribute name is specified, the ordering defaults to the one\n * specified in the default value for this attribute.\n *\n * When not specified, the order is\n * ascending.  This parameter can also be a function which takes two facet\n * values and should return a number, 0 if equal, 1 if the first argument is\n * bigger or -1 otherwise.\n *\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\n * the attribute requested (hierarchical, disjunctive or conjunctive)\n * @example\n * helper.on('result', function(event){\n *   //get values ordered only by name ascending using the string predicate\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\n *   //get values  ordered only by count ascending using a function\n *   event.results.getFacetValues('city', {\n *     // this is equivalent to ['count:asc']\n *     sortBy: function(a, b) {\n *       if (a.count === b.count) return 0;\n *       if (a.count > b.count)   return 1;\n *       if (b.count > a.count)   return -1;\n *     }\n *   });\n * });\n */\nSearchResults.prototype.getFacetValues = function(attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n  if (!facetValues) {\n    return undefined;\n  }\n\n  var options = defaultsPure({}, opts, {sortBy: SearchResults.DEFAULT_SORT});\n\n  if (Array.isArray(options.sortBy)) {\n    var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n    if (Array.isArray(facetValues)) {\n      return orderBy(facetValues, order[0], order[1]);\n    }\n    // If facetValues is not an array, it's an object thus a hierarchical facet object\n    return recSort(function(hierarchicalFacetValues) {\n      return orderBy(hierarchicalFacetValues, order[0], order[1]);\n    }, facetValues);\n  } else if (typeof options.sortBy === 'function') {\n    if (Array.isArray(facetValues)) {\n      return facetValues.sort(options.sortBy);\n    }\n    // If facetValues is not an array, it's an object thus a hierarchical facet object\n    return recSort(function(data) {\n      return vanillaSortFn(options.sortBy, data);\n    }, facetValues);\n  }\n  throw new Error(\n    'options.sortBy is optional but if defined it must be ' +\n    'either an array of string (predicates) or a sorting function'\n  );\n};\n\n/**\n * Returns the facet stats if attribute is defined and the facet contains some.\n * Otherwise returns undefined.\n * @param {string} attribute name of the faceted attribute\n * @return {object} The stats of the facet\n */\nSearchResults.prototype.getFacetStats = function(attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n\n  return undefined;\n};\n\n/**\n * @typedef {Object} FacetListItem\n * @property {string} name\n */\n\n/**\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\n * @param {string} facetName\n */\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, function(facet) {\n    return facet.name === facetName;\n  });\n  return data && data.stats;\n}\n\n/**\n * Returns all refinements for all filters + tags. It also provides\n * additional information: count and exhaustiveness for each filter.\n *\n * See the [refinement type](#Refinement) for an exhaustive view of the available\n * data.\n *\n * Note that for a numeric refinement, results are grouped per operator, this\n * means that it will return responses for operators which are empty.\n *\n * @return {Array.<Refinement>} all the refinements\n */\nSearchResults.prototype.getRefinements = function() {\n  var state = this._state;\n  var results = this;\n  var res = [];\n\n  Object.keys(state.facetsRefinements).forEach(function(attributeName) {\n    state.facetsRefinements[attributeName].forEach(function(name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n\n  Object.keys(state.facetsExcludes).forEach(function(attributeName) {\n    state.facetsExcludes[attributeName].forEach(function(name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function(attributeName) {\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function(name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function(attributeName) {\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function(name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n\n\n  Object.keys(state.numericRefinements).forEach(function(attributeName) {\n    var operators = state.numericRefinements[attributeName];\n    Object.keys(operators).forEach(function(operator) {\n      operators[operator].forEach(function(value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n\n  state.tagRefinements.forEach(function(name) {\n    res.push({type: 'tag', attributeName: '_tags', name: name});\n  });\n\n  return res;\n};\n\n/**\n * @typedef {Object} Facet\n * @property {string} name\n * @property {Object} data\n * @property {boolean} exhaustive\n */\n\n/**\n * @param {*} state\n * @param {*} type\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, function(f) {\n    return f.name === attributeName;\n  });\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\n  var exhaustive = (facet && facet.exhaustive) || false;\n\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\n/**\n * @param {*} state\n * @param {string} attributeName\n * @param {*} name\n * @param {Facet[]} resultsFacets\n */\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\n  var split = name.split(separator);\n  var rootFacet = find(resultsFacets, function(facet) {\n    return facet.name === attributeName;\n  });\n\n  var facet = split.reduce(function(intermediateFacet, part) {\n    var newFacet =\n      intermediateFacet && find(intermediateFacet.data, function(f) {\n        return f.name === part;\n      });\n    return newFacet !== undefined ? newFacet : intermediateFacet;\n  }, rootFacet);\n\n  var count = (facet && facet.count) || 0;\n  var exhaustive = (facet && facet.exhaustive) || false;\n  var path = (facet && facet.path) || '';\n\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: path,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\nmodule.exports = SearchResults;\n"]},"metadata":{},"sourceType":"script"}