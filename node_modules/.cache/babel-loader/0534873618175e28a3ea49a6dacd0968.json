{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport isEqual from 'react-fast-compare';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, refineValue, getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var page = 1;\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, page);\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n\n  return currentRefinement;\n}\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var _this = this;\n\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    this._allResults = this._allResults || [];\n    this._prevState = this._prevState || {};\n\n    if (!results) {\n      return {\n        hits: [],\n        hasPrevious: false,\n        hasMore: false,\n        refine: function refine() {},\n        refinePrevious: function refinePrevious() {},\n        refineNext: function refineNext() {}\n      };\n    }\n\n    var page = results.page,\n        hits = results.hits,\n        hitsPerPage = results.hitsPerPage,\n        nbPages = results.nbPages,\n        _results$_state = results._state;\n    _results$_state = _results$_state === void 0 ? {} : _results$_state;\n\n    var p = _results$_state.page,\n        currentState = _objectWithoutProperties(_results$_state, [\"page\"]);\n\n    var hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    var hitsWithPositionsAndQueryID = addQueryID(hitsWithPositions, results.queryID);\n\n    if (this._firstReceivedPage === undefined || !isEqual(currentState, this._prevState)) {\n      this._allResults = _toConsumableArray(hitsWithPositionsAndQueryID);\n      this._firstReceivedPage = page;\n      this._lastReceivedPage = page;\n    } else if (this._lastReceivedPage < page) {\n      this._allResults = [].concat(_toConsumableArray(this._allResults), _toConsumableArray(hitsWithPositionsAndQueryID));\n      this._lastReceivedPage = page;\n    } else if (this._firstReceivedPage > page) {\n      this._allResults = [].concat(_toConsumableArray(hitsWithPositionsAndQueryID), _toConsumableArray(this._allResults));\n      this._firstReceivedPage = page;\n    }\n\n    this._prevState = currentState;\n    var hasPrevious = this._firstReceivedPage > 0;\n    var lastPageIndex = nbPages - 1;\n    var hasMore = page < lastPageIndex;\n\n    var refinePrevious = function refinePrevious(event) {\n      return _this.refine(event, _this._firstReceivedPage - 1);\n    };\n\n    var refineNext = function refineNext(event) {\n      return _this.refine(event, _this._lastReceivedPage + 1);\n    };\n\n    return {\n      hits: this._allResults,\n      hasPrevious: hasPrevious,\n      hasMore: hasMore,\n      refinePrevious: refinePrevious,\n      refineNext: refineNext\n    };\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }) - 1\n    });\n  },\n  refine: function refine(props, searchState, event, index) {\n    if (index === undefined && this._lastReceivedPage !== undefined) {\n      index = this._lastReceivedPage + 1;\n    } else if (index === undefined) {\n      index = getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      });\n    }\n\n    var id = getId();\n\n    var nextValue = _defineProperty({}, id, index + 1);\n\n    var resetPage = false;\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, resetPage);\n  }\n});","map":{"version":3,"sources":["C:/Users/Sonja/search/search/node_modules/react-instantsearch-core/dist/es/connectors/connectInfiniteHits.js"],"names":["_defineProperty","_toConsumableArray","_objectWithoutProperties","isEqual","createConnector","getCurrentRefinementValue","refineValue","getResults","addAbsolutePositions","addQueryID","getId","getCurrentRefinement","props","searchState","context","id","page","currentRefinement","parseInt","displayName","getProvidedProps","searchResults","_this","results","ais","contextValue","multiIndexContext","indexContextValue","_allResults","_prevState","hits","hasPrevious","hasMore","refine","refinePrevious","refineNext","hitsPerPage","nbPages","_results$_state","_state","p","currentState","hitsWithPositions","hitsWithPositionsAndQueryID","queryID","_firstReceivedPage","undefined","_lastReceivedPage","concat","lastPageIndex","event","getSearchParameters","searchParameters","setQueryParameters","index","nextValue","resetPage"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport isEqual from 'react-fast-compare';\nimport createConnector from '../core/createConnector';\nimport { getCurrentRefinementValue, refineValue, getResults } from '../core/indexUtils';\nimport { addAbsolutePositions, addQueryID } from '../core/utils';\n\nfunction getId() {\n  return 'page';\n}\n\nfunction getCurrentRefinement(props, searchState, context) {\n  var id = getId();\n  var page = 1;\n  var currentRefinement = getCurrentRefinementValue(props, searchState, context, id, page);\n\n  if (typeof currentRefinement === 'string') {\n    return parseInt(currentRefinement, 10);\n  }\n\n  return currentRefinement;\n}\n/**\n * InfiniteHits connector provides the logic to create connected\n * components that will render an continuous list of results retrieved from\n * Algolia. This connector provides a function to load more results.\n * @name connectInfiniteHits\n * @kind connector\n * @providedPropType {array.<object>} hits - the records that matched the search state\n * @providedPropType {boolean} hasMore - indicates if there are more pages to load\n * @providedPropType {function} refine - call to load more results\n */\n\n\nexport default createConnector({\n  displayName: 'AlgoliaInfiniteHits',\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var _this = this;\n\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    this._allResults = this._allResults || [];\n    this._prevState = this._prevState || {};\n\n    if (!results) {\n      return {\n        hits: [],\n        hasPrevious: false,\n        hasMore: false,\n        refine: function refine() {},\n        refinePrevious: function refinePrevious() {},\n        refineNext: function refineNext() {}\n      };\n    }\n\n    var page = results.page,\n        hits = results.hits,\n        hitsPerPage = results.hitsPerPage,\n        nbPages = results.nbPages,\n        _results$_state = results._state;\n    _results$_state = _results$_state === void 0 ? {} : _results$_state;\n\n    var p = _results$_state.page,\n        currentState = _objectWithoutProperties(_results$_state, [\"page\"]);\n\n    var hitsWithPositions = addAbsolutePositions(hits, hitsPerPage, page);\n    var hitsWithPositionsAndQueryID = addQueryID(hitsWithPositions, results.queryID);\n\n    if (this._firstReceivedPage === undefined || !isEqual(currentState, this._prevState)) {\n      this._allResults = _toConsumableArray(hitsWithPositionsAndQueryID);\n      this._firstReceivedPage = page;\n      this._lastReceivedPage = page;\n    } else if (this._lastReceivedPage < page) {\n      this._allResults = [].concat(_toConsumableArray(this._allResults), _toConsumableArray(hitsWithPositionsAndQueryID));\n      this._lastReceivedPage = page;\n    } else if (this._firstReceivedPage > page) {\n      this._allResults = [].concat(_toConsumableArray(hitsWithPositionsAndQueryID), _toConsumableArray(this._allResults));\n      this._firstReceivedPage = page;\n    }\n\n    this._prevState = currentState;\n    var hasPrevious = this._firstReceivedPage > 0;\n    var lastPageIndex = nbPages - 1;\n    var hasMore = page < lastPageIndex;\n\n    var refinePrevious = function refinePrevious(event) {\n      return _this.refine(event, _this._firstReceivedPage - 1);\n    };\n\n    var refineNext = function refineNext(event) {\n      return _this.refine(event, _this._lastReceivedPage + 1);\n    };\n\n    return {\n      hits: this._allResults,\n      hasPrevious: hasPrevious,\n      hasMore: hasMore,\n      refinePrevious: refinePrevious,\n      refineNext: refineNext\n    };\n  },\n  getSearchParameters: function getSearchParameters(searchParameters, props, searchState) {\n    return searchParameters.setQueryParameters({\n      page: getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }) - 1\n    });\n  },\n  refine: function refine(props, searchState, event, index) {\n    if (index === undefined && this._lastReceivedPage !== undefined) {\n      index = this._lastReceivedPage + 1;\n    } else if (index === undefined) {\n      index = getCurrentRefinement(props, searchState, {\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      });\n    }\n\n    var id = getId();\n\n    var nextValue = _defineProperty({}, id, index + 1);\n\n    var resetPage = false;\n    return refineValue(searchState, nextValue, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, resetPage);\n  }\n});"]},"metadata":{},"sourceType":"module"}