{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from './createWidgetsManager';\nimport createStore from './createStore';\nimport { HIGHLIGHT_TAGS } from './highlight';\nimport { hasMultipleIndices } from './indexUtils';\nimport { version as ReactVersion } from 'react';\nimport version from './version';\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  if (isIndexWidget(firstWidget)) {\n    return -1;\n  }\n\n  if (isIndexWidget(secondWidget)) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: [],\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread({}, indices, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results[indexId] = event.results;\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n      store.setState(_objectSpread({}, partialState, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: false,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n    store.setState(_objectSpread({}, partialState, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, [\"resultsFacetValues\"]);\n\n        store.setState(_objectSpread({}, partialState, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if (!client.transporter && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter) {\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread({}, request, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results)) {\n      return results.reduce(function (acc, result) {\n        return _objectSpread({}, acc, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread({}, store.getState(), {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread({}, store.getState(), {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits; // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread({}, store.getState(), {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread6;\n\n      store.setState(_objectSpread({}, store.getState(), {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread({}, store.getState().resultsFacetValues, (_objectSpread6 = {}, _defineProperty(_objectSpread6, facetName, content.facetHits), _defineProperty(_objectSpread6, \"query\", query), _objectSpread6))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread({}, store.getState(), {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}","map":{"version":3,"sources":["C:/Users/Sonja/search/search/node_modules/react-instantsearch-core/dist/es/core/createInstantSearchManager.js"],"names":["_objectWithoutProperties","_defineProperty","_objectSpread","algoliasearchHelper","createWidgetsManager","createStore","HIGHLIGHT_TAGS","hasMultipleIndices","version","ReactVersion","addAlgoliaAgents","searchClient","addAlgoliaAgent","concat","isMultiIndexContext","widget","ais","props","contextValue","multiIndexContext","indexContextValue","isTargetedIndexEqualIndex","indexId","targetedIndex","isIndexWidget","Boolean","isIndexWidgetEqualIndex","sortIndexWidgetsFirst","firstWidget","secondWidget","serializeQueryParameters","parameters","isObjectOrArray","value","Object","prototype","toString","call","encode","format","_len","arguments","length","args","Array","_key","i","replace","encodeURIComponent","keys","map","key","JSON","stringify","join","createInstantSearchManager","_ref","indexName","_ref$initialState","initialState","resultsState","stalledSearchDelay","helper","on","handleNewSearch","handleSearchSuccess","handleSearchError","skip","stalledSearchTimer","initialSearchParameters","state","widgetsManager","onWidgetsUpdate","hydrateSearchClient","store","widgets","metadata","results","hydrateResultsState","error","searching","isSearchStalled","searchingForFacetValues","skipSearch","updateClient","client","setClient","search","clearCache","getMetadata","getWidgets","filter","getSearchParameters","sharedParameters","reduce","res","mainParameters","targetedIndexEqualMainIndex","subIndexEqualMainIndex","sort","derivedIndices","targetedIndexNotEqualMainIndex","subIndexNotEqualMainIndex","indices","derivedParameters","_getSearchParameters","derivedHelpers","slice","forEach","derivedHelper","detach","_ref2","derive","setState","_ref3","event","getState","isDerivedHelpersEmpty","getFacetByName","currentState","nextIsSearchStalled","hasPendingRequests","clearTimeout","resultsFacetValues","partialState","_ref4","setTimeout","_store$getState","transporter","_useCache","baseMethod","requests","_len2","methodArgs","_key2","requestsWithSerializedParams","request","params","responsesCache","get","method","apply","isArray","hydrateSearchClientWithMultiIndexRequest","hydrateSearchClientWithSingleIndexRequest","set","acc","result","rawResults","index","cache","_internalIndexId","SearchResults","SearchParameters","transitionState","nextSearchState","searchState","onExternalStateUpdate","onSearchForFacetValues","_ref5","facetName","query","_ref5$maxFacetHits","maxFacetHits","maxFacetHitsWithinRange","Math","max","min","searchForFacetValues","then","content","_objectSpread6","facetHits","catch","updateIndex","newIndex","setIndex","getWidgetsIds","meta","id"],"mappings":"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","sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from './createWidgetsManager';\nimport createStore from './createStore';\nimport { HIGHLIGHT_TAGS } from './highlight';\nimport { hasMultipleIndices } from './indexUtils';\nimport { version as ReactVersion } from 'react';\nimport version from './version';\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  if (isIndexWidget(firstWidget)) {\n    return -1;\n  }\n\n  if (isIndexWidget(secondWidget)) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: [],\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread({}, indices, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results[indexId] = event.results;\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n      store.setState(_objectSpread({}, partialState, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: false,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, [\"resultsFacetValues\"]);\n\n    store.setState(_objectSpread({}, partialState, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, [\"resultsFacetValues\"]);\n\n        store.setState(_objectSpread({}, partialState, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if (!client.transporter && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter) {\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread({}, request, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread({}, client.cache, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results)) {\n      return results.reduce(function (acc, result) {\n        return _objectSpread({}, acc, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread({}, store.getState(), {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread({}, store.getState(), {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits;\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread({}, store.getState(), {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread6;\n\n      store.setState(_objectSpread({}, store.getState(), {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread({}, store.getState().resultsFacetValues, (_objectSpread6 = {}, _defineProperty(_objectSpread6, facetName, content.facetHits), _defineProperty(_objectSpread6, \"query\", query), _objectSpread6))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread({}, store.getState(), {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}"]},"metadata":{},"sourceType":"module"}